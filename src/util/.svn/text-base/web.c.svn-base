#include "util/json-support.h"
#include "astring.h"

#include "util/web.h"
#include "fragments/vquery.html.h"
#include "fragments/subgraph.html.h"
#include "csv.h"

static stinger_t * S = NULL;

void
web_start_stinger(stinger_t * stinger, const char * port) {
  S = stinger;

  struct mg_context *ctx;
  struct mg_callbacks callbacks;

  // List of options. Last element must be NULL.
  const char *opts[] = {"listening_ports", port, NULL};

  // Prepare callbacks structure. We have only one callback, the rest are NULL.
  memset(&callbacks, 0, sizeof(callbacks));
  callbacks.begin_request = begin_request_handler;

  // Start the web server.
  ctx = mg_start(&callbacks, NULL, opts);
}

enum sections {
  SEC_ADMIN,
  SEC_VQUERY,
  SEC_SUBGRAPH,
  SEC_RESULTS,
  SEC_MAX
};

int
get_head_and_nav(char * buf, int buf_len, int section) {
  char * title = NULL;
  switch (section) {
    default:
    case SEC_ADMIN:
    title = "Admin";
    break;
    case SEC_VQUERY:
    title = "vQuery";
    break;
    case SEC_SUBGRAPH:
    title = "Subgraph";
    break;
    case SEC_RESULTS:
    title = "Results";
    break;
  }

  int len = snprintf(buf, buf_len,
"<!DOCTYPE html> \
<html lang=\"en\"> \
<head> \
<title>STINGER WebUI - %s</title> \
<link rel=\"stylesheet\" type=\"text/css\" href=\"/data/bootstrap/css/bootstrap_stinger.css\" /> \
<script src=\"http://code.jquery.com/jquery-latest.js\"></script> \
<script src=\"/data/d3/d3.v3.min.js\"></script> \
<style> \
.node { \
stroke: #fff; \
stroke-width: 1.5px; \
} \
 \
.link { \
stroke: #999; \
stroke-width: 2px; \
stroke-opacity: .6; \
} \
 \
</style> \
</head> \
<body style=\"padding-top:40px;\"> \
  <div class=\"navbar navbar-inverse navbar-fixed-top\"> \
    <div class=\"navbar-inner\"> \
      <a class=\"brand\" href=\"/\">Call Log Data Browser</a> \
      <ul class=\"nav\"> \
       <li %s><a href=\"/\">Dashboard</a></li> \
       <li><a href=\"/data/php/callsearch.php\">Call Search</a></li> \
       <li><a href=\"/data/php/celltower.php\">Cell Tower Rerport</a></li> \
       <li %s><a href=\"/vquery\">vQuery</a></li> \
       <li %s><a href=\"/subgraph\">Subgraph</a></li> \
       <li %s><a href=\"/results\">Results</a></li> \
      </ul> \
    </div> \
  </div>", title,
  section == SEC_ADMIN ? "class=\"active\"" : "",
  section == SEC_VQUERY ? "class=\"active\"" : "",
  section == SEC_SUBGRAPH ? "class=\"active\"" : "",
  section == SEC_RESULTS ? "class=\"active\"" : "");
  return len;
}

string_t *
get_physid_json(stinger_t * S, char * stinger_ids) {
  string_t * rtn = string_new_from_cstr("{");

  char * sub = calloc(strlen(stinger_ids) + 2, sizeof(char));
  memcpy(sub, stinger_ids, strlen(stinger_ids));
  char * buf = NULL;
  uint64_t bufSize = 0;
  char ** fields = NULL;
  uint64_t * lengths = NULL;
  uint64_t fieldsSize = 0;
  uint64_t count = 0;

  splitLineCSVDynamic(',', sub, strlen(sub), &buf, &bufSize, &fields, &lengths, &fieldsSize, &count);

  int64_t found = 0;
  for(uint64_t i = 0; i < count; i++) {
    char * mapping;
    int64_t mapping_len;
    int64_t vtx = atol(fields[i]);
    if(-1 != stinger_mapping_physid_direct(S, vtx, &mapping, &mapping_len)) {
      if(found) {
	string_append_cstr(rtn, ",\n");
      }

      string_append_cstr(rtn, "  \"");
      string_append_cstr_len(rtn, fields[i], lengths[i]);
      string_append_cstr(rtn, "\": \"");
      string_append_cstr_len(rtn, mapping, mapping_len);
      string_append_cstr(rtn, "\"");

      found++;
    }
  }

  string_append_cstr(rtn, "\n}");

  free(sub);

  return rtn;
}

string_t *
get_stingerid_json(stinger_t * S, char * phys_ids) {
  string_t * rtn = string_new_from_cstr("{");

  char * sub = calloc(strlen(phys_ids) + 2, sizeof(char));
  memcpy(sub, phys_ids, strlen(phys_ids));
  char * buf = NULL;
  uint64_t bufSize = 0;
  char ** fields = NULL;
  uint64_t * lengths = NULL;
  uint64_t fieldsSize = 0;
  uint64_t count = 0;

  splitLineCSVDynamic(',', sub, strlen(sub), &buf, &bufSize, &fields, &lengths, &fieldsSize, &count);

  int64_t found = 0;
  char intbuf[256];
  for(uint64_t i = 0; i < count; i++) {
    int64_t vtx = stinger_mapping_lookup(S, fields[i], lengths[i]);
    if(vtx < STINGER_MAX_LVERTICES && vtx >= 0) {
      if(found) {
	string_append_cstr(rtn, ",\n");
      }

      string_append_cstr(rtn, "  \"");
      string_append_cstr(rtn, fields[i]);
      string_append_cstr(rtn, "\":");
      sprintf(intbuf, "%ld", vtx);
      string_append_cstr(rtn, intbuf);

      found++;
    }
  }

  string_append_cstr(rtn, "\n}");

  free(sub);

  return rtn;
}

int
begin_request_handler(struct mg_connection *conn)
{
  const struct mg_request_info *request_info = mg_get_request_info(conn);

  if(request_info->uri && (0 == strncmp(request_info->uri, "/data", 5) || strlen(request_info->uri) <= 1)) {
    return 0;
  }

  char * content = calloc(1048576, sizeof(char));
  int content_size = 1048576;
  int content_length = 0;
  int handled = 0;

  if(0 == strncmp(request_info->uri, "/getphysid", 10)) {
    const char * suburi = request_info->uri + 7;
    if(suburi[0] == '/') suburi++;

    string_t * mappings = get_physid_json(S, suburi);
    mg_printf(conn,
	"HTTP/1.1 200 OK\r\n"
	"Content-Type: text/plain\r\n"
	"Content-Length: %d\r\n"        // Always set Content-Length
	"\r\n"
	"%s",
	mappings->len, mappings->str);
    string_free(mappings);
    return 1;
  }

  if(0 == strncmp(request_info->uri, "/vquery", 7)) {
    handled = 1;

    const char * suburi = request_info->uri + 7;
    if(suburi[0] == '/') suburi++;
    
    if(0 == strncmp(suburi, "data/", 5)) {
      suburi += 5;
      int64_t vtx = atol(suburi);
      if(vtx < STINGER_MAX_LVERTICES && vtx >= 0) {
	string_t * egonet = egonet_to_json(S, vtx);
	mg_printf(conn,
	    "HTTP/1.1 200 OK\r\n"
	    "Content-Type: text/plain\r\n"
	    "Content-Length: %d\r\n"        // Always set Content-Length
	    "\r\n"
	    "%s",
	    string_length(egonet), egonet->str);
	string_free(egonet);
	return 1;
      }
    }

    int64_t vtx;
    if(0 == strncmp(suburi, "byphysid/", 9)) {
      suburi += 9;
      vtx = stinger_mapping_lookup(S, suburi, strlen(suburi));
    } else {
      vtx = atol(suburi);
    }
    if(vtx >= STINGER_MAX_LVERTICES || vtx < 0) {
      vtx = 0;
    }

    int head_len = get_head_and_nav(content, content_size, SEC_VQUERY);
    content_length = head_len + snprintf(content + head_len, content_size - head_len, vquery_html, vtx);
  }

  if(0 == strncmp(request_info->uri, "/subgraph", 9)) {
    handled = 1;

    const char * suburi = request_info->uri + 9;
    if(suburi[0] == '/') suburi++;
    
    if(0 == strncmp(suburi, "data/", 5)) {
      suburi += 5;

      char * sub = calloc(strlen(suburi) + 2, sizeof(char));
      memcpy(sub, suburi, strlen(suburi));
      char * buf = NULL;
      uint64_t bufSize = 0;
      char ** fields = NULL;
      uint64_t * lengths = NULL;
      uint64_t fieldsSize = 0;
      uint64_t count = 0;

      splitLineCSVDynamic(',', sub, strlen(sub), &buf, &bufSize, &fields, &lengths, &fieldsSize, &count);

      int64_t * group_vertices = malloc(sizeof(int64_t) * count);
      int64_t found = 0;
      for(uint64_t i = 0; i < count; i++) {
	group_vertices[found] = atol(fields[i]);
	if(group_vertices[found] >= STINGER_MAX_LVERTICES || group_vertices[found] < 0) {
	  group_vertices[found] = 0;
	} else {
	  found++;
	}
      }

      string_t * group = group_to_json(S, group_vertices, found);

      mg_printf(conn,
	  "HTTP/1.1 200 OK\r\n"
	  "Content-Type: text/plain\r\n"
	  "Content-Length: %d\r\n"        // Always set Content-Length
	  "\r\n"
	  "%s",
	  string_length(group), group->str);

      string_free(group);
      free(buf); free(fields); free(lengths); free(group_vertices); free(sub);

      return 1;
    }

    const char * vtx = suburi;
    char * tmp_buf = NULL;
    if(0 == strncmp(suburi, "byphysid/", 9)) {
      suburi += 9;

      char * sub = calloc(strlen(suburi) + 2, sizeof(char));
      memcpy(sub, suburi, strlen(suburi));
      char * buf = NULL;
      uint64_t bufSize = 0;
      char ** fields = NULL;
      uint64_t * lengths = NULL;
      uint64_t fieldsSize = 0;
      uint64_t count = 0;

      splitLineCSVDynamic(',', sub, strlen(sub), &buf, &bufSize, &fields, &lengths, &fieldsSize, &count);

      int64_t * group_vertices = malloc(sizeof(int64_t) * count);
      int64_t found = 0;
      for(uint64_t i = 0; i < count; i++) {
	group_vertices[found] = stinger_mapping_lookup(S, fields[i], lengths[i]);
	if(group_vertices[found] >= STINGER_MAX_LVERTICES || group_vertices[found] < 0) {
	  group_vertices[found] = 0;
	} else {
	  found++;
	}
      }

      tmp_buf = malloc(sizeof(char) * 40 * count);
      vtx = tmp_buf;
      int so_far = 0;
      for(uint64_t i = 0; i < found; i++) {
	so_far += sprintf(tmp_buf + so_far, "%ld,", group_vertices[i]);
      }

      free(buf); free(fields); free(lengths); free(sub);
    }

    int head_len = get_head_and_nav(content, content_size, SEC_SUBGRAPH);
    content_length = head_len + snprintf(content + head_len, content_size - head_len, subgraph_html, vtx, vtx);

    if(tmp_buf) free(tmp_buf);
  }

  if(!handled || (0 == strncmp(request_info->uri, "/admin", 7))) {
    int head_len = get_head_and_nav(content, content_size, SEC_ADMIN);
    content_length = head_len + snprintf(content + head_len, content_size - head_len,
      "<div class=\"container\"> \
	<div class=\"row\"><h2>STINGER Workflow</h2></div> \
	<div class=\"row\"><div class=\"span5\"><h2>Current Streams</h2><ul>");


    content_length +=  snprintf(content + content_length, 
      content_size - content_length, "</ul></div><div class=\"span5 offset2\"><h2>Current Algorithms</h2><ul>\n");

      
    content_length +=  snprintf(content + content_length, content_size - content_length, "</div> \
      </div> \
      </div> \
      </body> \
      </html>");
  }

  // Send HTTP reply to the client
  mg_printf(conn,
      "HTTP/1.1 200 OK\r\n"
      "Content-Type: text/html\r\n"
      "Content-Length: %d\r\n"        // Always set Content-Length
      "\r\n"
      "%s",
      content_length, content);

  free(content);

  // Returning non-zero tells mongoose that our function has replied to
  // the client, and mongoose should not send client any more data.
  return 1;
}
